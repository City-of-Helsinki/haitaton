package fi.hel.haitaton.hanke

import mu.KotlinLogging
import org.geojson.FeatureCollection
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.time.ZonedDateTime

private val logger = KotlinLogging.logger { }

@RestController
@RequestMapping("/hankkeet")
class HankeController(@Autowired private val service: HankeService) {

    //TODO: get service for saving new Hanke

    /**
     * Get one hanke with hankeId.
     *  TODO: token and user from front?
     *  TODO: logging
     *  TODO: validation for input
     *  TODO: ask hankeId to be generated by an service before calling saving...or where?
     *
     */
    @GetMapping
    fun getHankeById(@RequestParam(name = "hankeId") hankeId: String?): ResponseEntity<Hanke> {
        return if (hankeId == null) {
            ResponseEntity.badRequest().build() //TODO, error handling
        } else {
            val hanke = loadHanke(hankeId)
            if (hanke == null) {
                ResponseEntity.notFound().build() //TODO, error handling
            } else {
                ResponseEntity.ok(hanke)
            }
        }
    }

    /**
     * Add one hanke.
     *  TODO: token and user from front?
     *  TODO: logging
     *  TODO: validation for input
     *  TODO: ask hankeId to be generated by an service before calling saving...or where?
     *
     */
    @PostMapping()
    fun createHanke(@RequestBody hanke: Hanke?): ResponseEntity<Any> {
        return if (hanke == null)/*TODO: can this happen?*/ {
            ResponseEntity.badRequest().body("hanke puuttuu") //TODO, error handling
        } else {
            hanke.hankeId = getHankeId()
            // TODO call service to save
            ResponseEntity.ok(hanke)
        }
    }

    @PostMapping("/{hankeId}/geometriat")
    fun createGeometria(@PathVariable("hankeId") hankeId: String, @RequestBody hankeGeometria: FeatureCollection?): ResponseEntity<Any> {
        if (hankeGeometria == null) {
            return ResponseEntity.badRequest().body(HankeError("HAI1011", "Invalid Hanke {hankeId} geometry", mapOf(Pair("hankeId", hankeId))))
        }
        try {
            service.saveGeometria(hankeId, hankeGeometria)
        } catch (e: HankeNotFoundException) {
            logger.error(e) {
                "HAI1001 - Hanke $hankeId not found"
            }
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(HankeError("HAI1001", "Hanke {hankeId} not found", mapOf(Pair("hankeId", hankeId))))
        } catch (e: Exception) {
            logger.error(e) {
                "HAI1012 - Internal error while saving Hanke $hankeId geometry"
            }
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HankeError("HAI1012", "Internal error while saving Hanke {hankeId} geometry", mapOf(Pair("hankeId", hankeId))))
        }
        return ResponseEntity.noContent().build()
    }

    //temporary object creator for getting started TODO: Real implementation for returning hanke from backend
    private fun loadHanke(hankeId: String): Hanke? {
        return Hanke(hankeId, "Mannerheimintien remontti remonttinen", ZonedDateTime.now(), ZonedDateTime.now(), "Risto", 1)
    }

    //to get new id for hankeId, TODO: this needs real implementation
    private fun getHankeId(): String {
        return "CREATED123"
    }
}